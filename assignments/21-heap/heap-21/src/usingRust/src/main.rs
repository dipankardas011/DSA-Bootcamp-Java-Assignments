use std::collections::HashSet;

// CAUTION: GENERATED BY CHATGPT
struct ExamRoom {
    n: i32,
    occupied_seats: HashSet<i32>,
}

impl ExamRoom {
    fn new(n: i32) -> Self {
        ExamRoom {
            n,
            occupied_seats: HashSet::new(),
        }
    }

    fn seat(&mut self) -> i32 {
        let n = self.n;
        let occupied_seats = &self.occupied_seats;

        if occupied_seats.is_empty() {
            self.occupied_seats.insert(0);
            return 0;
        }

        let mut max_distance = std::i32::MIN;
        let mut seat = 0;

        // Check the distance between seats and select the one with the maximum distance.
        for i in 0..n {
            if occupied_seats.contains(&i) {
                continue;
            }

            let mut min_distance = std::i32::MAX;
            for &j in occupied_seats {
                let distance = (i - j).abs();
                min_distance = std::cmp::min(min_distance, distance);
            }

            if min_distance > max_distance || (min_distance == max_distance && i < seat) {
                max_distance = min_distance;
                seat = i;
            }
        }

        self.occupied_seats.insert(seat);
        seat
    }

    fn leave(&mut self, p: i32) {
        self.occupied_seats.remove(&p);
    }
}
fn main() {
    let mut exam_room = ExamRoom::new(10);
    let seat1 = exam_room.seat(); // Returns 0
    let seat2 = exam_room.seat(); // Returns 9
    let seat3 = exam_room.seat(); // Returns 4
    exam_room.leave(seat2);
    let seat4 = exam_room.seat(); // Returns 2
    println!("{seat1} {seat2} {seat3} {seat4}");
}

